#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

template <typename Object>
class List
{
private:

    struct Node
    {
        Object  data;
        Node   *next;
        
        Node( const Object & d = Object{ },  Node * n = nullptr )
        : data{ d },  next{ n } { }
        
        Node( Object && d, Node * n = nullptr )
        : data{ std::move( d ) }, next{ n } { }
    };
    
public:
    class iterator
    {
    public:
        
        iterator( ): current( nullptr )
        { }
        
        Object & operator* ( )
        { return current->data; }
        
        const Object & operator* ( ) const
        { return  current->data; }
        
        iterator & operator++ ( )
        {
            this->current = this->current->next;
            return *this;
        }
        
        iterator operator++ ( int )
        {
            iterator old = *this;
            ++( *this );
            return old;
        }
        
        bool operator== ( const iterator & rhs ) const
        { return current == rhs.current; }
        
        bool operator!= ( const iterator & rhs ) const
        { return !( *this == rhs ); }
        
    private:
        Node * current;

        iterator( Node *p ) : current{ p }
        { }
        
        friend class List<Object>;
    };
    
public:
    List( )
    { header = new Node(); }
        
    List( const List & rhs );

    ~List( );

    List & operator= ( const List & rhs )
    {
        List copy = rhs;
        std::swap( *this, copy );
        return *this;
    }
    
    List( List && rhs ):header{ new Node }
    {
        header->next = rhs.header->next;
        rhs.header->next = nullptr;
    }
    
    List & operator= ( List && rhs )
    {
        std::swap( header, rhs.header );
        return *this;
    }
    
    iterator begin( ) const
    { return iterator( header->next ); }
    
    iterator end( ) const
    { return iterator( nullptr ); }
    
    iterator before_begin( ) const
    { return iterator( header ); }
    
    bool empty( ) const
    { return header->next == nullptr; }
    
    void clear( )
    {
        while( !empty( ) )
            pop_front( );
    }
    
    void push_front(Object data){
        header->data = data;
        Node* oldHeader = header;
        header = new Node;
        header->next = oldHeader;
    }

    void pop_front( )
    { erase_after( before_begin( ) ); }
    
    iterator insert_after( iterator itr, const Object & x )
    {
        Node *p = itr.current;
        p->next = new Node{ x, p->next };
        
        return iterator(p->next);
    }

    iterator erase_after( iterator itr )
    {
        Node *p = itr.current;
        Node *oldNode = p->next;
        
        p->next = oldNode->next;
        delete oldNode;
        
        return iterator( p->next );
    }
    
    Object & front( );
    
    const Object & front( ) const;
    
    void merge( List & alist );

    void remove_adjacent_duplicates( );
    
    template<class Predicate>
    void remove_if( Predicate pred );
        
private:
    Node *header;
};

SCENARIO("Testing Copy Constructor"){
    GIVEN("An instance of the list class"){
        List<int> l;
        l.push_front(3);
        l.push_front(2);
        l.push_front(1);
        WHEN("The copy constructor is invoked"){
            List<int> l2(l); 
            THEN("A deep copy should have been made"){
                List<int>::iterator itr1 = l.begin();
                List<int>::iterator itr2 = l2.begin();
                while(itr2 != l2.end() && itr1 != l.end()){
                    REQUIRE(*itr2 == *itr1);
                    ++itr2;
                    ++itr1;
                }
                REQUIRE(itr1 == l.end());
                REQUIRE(itr2 == l2.end());
                l.clear();
                REQUIRE(l.empty());
                REQUIRE(!l2.empty());
            }
        }
    }
}

template<class Object>
List<Object>::List(const List& rhs){
    header = new Node();
    Node* curr = header;
    Node* otherCurr = rhs.header->next;
    auto iter = rhs.begin();
    while(iter != rhs.end()){
        curr->next = new Node(*iter);
        ++iter;
        curr = curr->next;
    }
}

template<class Object>
List<Object>::~List(){
   Node* curr = header;
   while(curr->next != nullptr){
        Node* tmp = curr->next->next;
        delete curr->next;
        curr->next = tmp;
   }
   delete header;
}


template<class Object>
Object& List<Object>::front(){
    if(header->next == nullptr){
        return header->data; 
    }
    return header->next->data;
}

template<class Object>
const Object & List<Object>::front( ) const{
    if(header->next == nullptr){
        return header->data; 
    }
    return header->next->data;
}
